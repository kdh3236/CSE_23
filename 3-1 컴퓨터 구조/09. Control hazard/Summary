모든 명령어는 control signal에 의해 제어되기 때문에, Control dependecy도 제거해야 한다.
  - 이는 곧 pc에 대한 data dependency와 동일한 맥락이다.
  - Branch, Jump 때문에 IF 했던 명령어가 FLUSH 되어야 할 수 있다.

Branch를 제외하고 PC에 대해 모든 명령어가 use - produce 간의 one distance를 가지고 있다.
  - Branch는 distance = 2
    - target address 계산 때문

기본적으로 one cycle stall이 걸려야한다.
  - 근데 이렇게 해도 Branch는 해결이 안 된다.
  - 그럼 Branch에서 target address 계산하는 부분을 추가적인 하드웨어를 만들어서 ID stage로 앞당기면 어떨까?
  - 하지만, 앞당기게 되면 data hazard 위험이 증가한다.

해결법: Branch delay slot

위 해결책 모두 stall을 사용한다.
  - 만약 pipeline stage가 여러 단계로 나누어지면, stall이 오랜 시간 걸려야될 수도 있다.

그래서 우리는 Branch가 Taken / Not taken 여부를 예측해야 한다.
  1. Always Not Taken 
    - PC + 4로 예측

  2. Always Taken
    - Target address를 예상해야 한다. 

Always Taken의 경우 Target address는 어떻게 계산할까?
Branch Target Buffer(BTB)를 이용하자.
  - PC값을 index로 하여 예상 Target addr를 반환하는 버퍼

  1. 이상적인 경우 - BTB가 무한히 크다.

  2. BTB는 무한히 클 수 없다.
    - 일부분을 index로 사용하자.
    - pc는 LSB가 2b'00 이므로, LSB에서 3번째 부터 N+1까지 index로 사용해야 한다.
    - 이 때, BTB 크기는 2^N

    - PC의 일부분만 index로 사용하면 중복되는 부분이 생길 수도 있다.
    - 따라서 TAG를 사용한다.
    - TAG와 맞지 않으면 그냥 PC+4, 맞으면 BTB에 저장된 Target address로 간다.

하지만, Always taken으로 예상을 하게되면, Forward branch에 대한 정확도가 너무 낮다.

그러므로 Taken에 대한 예측까지 해보자

  1. 1 bit predictor
    - 직전 예측을 따라감
  2. 2 bit predictor

이전까지의 것들은 one level predictor이다.
        

