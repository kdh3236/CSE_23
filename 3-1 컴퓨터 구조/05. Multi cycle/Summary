앞서 본 Single cycle의 경우, clock time을 worst case에 맞추어야 한다는 단점이 있었다.

이 문제를 해결하기 위해, 각 stage를 세분화하여 고정된 clock time으로 한 cycle이 동작하도록 하는 multi cycle을 생각해 볼 수 있다.
  - 한 cycle을 실행하는 동안 전체 hardware에서 특정 stage 작업만 실행하면 된다.

  - 만약 특정 명렁어가 다음 stage로 갈 필요가 없을 때, InstDone으로  다음 stage를 실행하지 않고, 다음 명령어를 실행할 수 있도록 한다.   

  - 같은 Hardware에서 stage에 따라 다른 동작을 하기 위해서는 control signal이 필요하다.
    - 이를 위해, utrl으로 명령어 종류(opcode)와 현재 상태(state)를 보고 next state와 알맞는 control signal을 출력 및 전달할 수 있도록 할 수 있다. 

추가로, 우리는 중복되는 Hardware resource를 하나로 합치고, timing만 조절해준다면 정상적으로 동작할 수 있도록 할 수 있다.   
  -  IF 단계에서 명령어를 memory에서 불러오고, MEM 단계에서 Memory에 접근하는 과정을 한 cycle 내에 처리할 필요가 없어 memory를 하나만 가지도록 할 수 있다.
  -  Branch target address를 계산하는 adder / pc + 4 adder / Alu_result adder 를 합칠 수 있다.

중요하게, Multi-cycle에서는 한 stage나 동작이 한 cycle안에 종료되지 않을 수도 있다. 이를 위해 추가적인 저장 공간이 필요하다.
  - MDR, IR, A, B ...
  - 만약 mem해서 읽어온 데이터가 있는데 wb은 다음 cycle에서 수행해야 한다면, 중간에 저장을 해놔야 한다. 
  - 이를 위해, 추가적인 저장 공간을 사용한다. 
  - 이를 MicroArchitecture 이라고 한다.

Register Transfer (RT)
  - 사실 Multi cycle이 동작하는 방식은 모두 Register간의 데이터 이동으로 확인할 수 있다.
  - 내부적으로 데이터 이동이 어떻게 발생하는지는 MicroArchitecture level에서 처리하고, Programmer는 Architecture level만 확인하면 된다.
  - Register간의 데이터 이동이 어떻게 일어나는지 확인하고, 그 동작을 지원하기 위해서 control signal을 세팅하는 방식을 사용할 수 있다.

Register transfer를 확인할 때, 어떤 방식으로 cycle을 나누어야 하는지가 굉장히 중요하다.
아래 규칙을 위반하면 같은 cycle에 위치하면 안 된다.
  1. 같은 Hardware resource를 같은 cycle 내에서 사용하면 안 된다.
  2. Register의 Read port는 2개, write port는 1개 이므로 한 cycle 내에서 read는 최대 2번, write는 최대 1번만 실행되어야 한다.
  3. 한 cycle에 Memory 접근은 한 번만 가능하다.
  4. 값을 확정하는 부분과 그 값을 사용하는 부분은 같은 cycle에 존재하면 안 된다.

따라서 Single cycle에서 본 한 stage 내에서도 여러 cycle로 나누어질 수 있고, 다른 stage라고 하더라도 하나의 cycle로 묶이게 될 수도 있다.

마지막으로 Single cylce보다 성능은 어떠한지 확인해보자.
  - single cycle에서의 CPI = 1, clock period = 1이라고 하자.
  - multi cycle에서 한 cluck period를 single cycle에서보다 12배 줄여 clock period는 1/12 , cpi는 8.5라고 하자.
  - Performance는 speedup 기준으로 [(1*1) / {8.5*(1/12)} = 1.4]배 빨라졌다고 할 수 있다.

다만, CPI가 너무 커지는 문제가 발생한다.
